import { useState, useCallback } from 'react';
import { supabase } from '@/lib/supabaseClient';
import { translateTranscriptOpenAI, translateTextOpenAI } from '@/lib/openAIService';
import { buildEditedTranscriptData } from '@/hooks/transcript/transcriptProcessingUtils';
import { getLocaleString } from '@/lib/locales';

const useTranslationManager = (currentLanguage, toast, episodes, setEpisodes) => {
  const [translatingFrom, setTranslatingFrom] = useState(null);
  const [translationProgress, setTranslationProgress] = useState({});
  const [isTranslating, setIsTranslating] = useState(false);

  // –ü–µ—Ä–µ–≤–æ–¥ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞ –∏ –≤–æ–ø—Ä–æ—Å–æ–≤ —Å —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —è–∑—ã–∫–∞ –Ω–∞ —Ü–µ–ª–µ–≤–æ–π —è–∑—ã–∫
  const translateEpisode = useCallback(async (sourceEpisode, targetLang, sourceLang, options = {}) => {
    const overwrite = options?.overwrite ?? true; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –ø–µ—Ä–µ–≤–æ–¥—ã –≤ –º–∞—Å—Å–æ–≤–æ–º —Ä–µ–∂–∏–º–µ
    const questionsOnly = options?.questionsOnly ?? false; // –§–ª–∞–≥ –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ —Ç–æ–ª—å–∫–æ –≤–æ–ø—Ä–æ—Å–æ–≤
    console.log('[translateEpisode] Starting translation:', {
      sourceSlug: sourceEpisode?.slug,
      sourceLang,
      targetLang,
      isTranslating,
      overwrite,
      questionsOnly
    });

    if (!sourceEpisode || !sourceEpisode.slug) {
      toast({
        title: getLocaleString('errorGeneric', currentLanguage),
        description: '–ò—Å—Ö–æ–¥–Ω—ã–π —ç–ø–∏–∑–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω',
        variant: 'destructive'
      });
      return false;
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∏–¥–µ—Ç –ª–∏ —É–∂–µ –ø–µ—Ä–µ–≤–æ–¥
    if (isTranslating) {
      console.log('[translateEpisode] Translation already in progress, skipping');
      return false;
    }

    // –í–∞–ª–∏–¥–∞—Ü–∏—è –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã—Ö —è–∑—ã–∫–æ–≤
    const supportedLanguages = ['en', 'es', 'ru', 'de', 'fr', 'pl'];
    if (!supportedLanguages.includes(targetLang)) {
      toast({
        title: getLocaleString('errorGeneric', currentLanguage),
        description: `–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ü–µ–ª–µ–≤–æ–π —è–∑—ã–∫: ${targetLang}`,
        variant: 'destructive'
      });
      return false;
    }

    if (!supportedLanguages.includes(sourceLang)) {
      toast({
        title: getLocaleString('errorGeneric', currentLanguage),
        description: `–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π –∏—Å—Ö–æ–¥–Ω—ã–π —è–∑—ã–∫: ${sourceLang}`,
        variant: 'destructive'
      });
      return false;
    }

    const translationKey = `${sourceEpisode.slug}-${sourceLang}-${targetLang}`;
    console.log('[translateEpisode] Setting translatingFrom to:', translationKey);
    setIsTranslating(true);
    setTranslatingFrom(translationKey);

    try {
      // 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞ —É –∏—Å—Ö–æ–¥–Ω–æ–≥–æ —ç–ø–∏–∑–æ–¥–∞
      const { data: sourceTranscript, error: sourceTranscriptError } = await supabase
        .from('transcripts')
        .select('*')
        .eq('episode_slug', sourceEpisode.slug)
        .eq('lang', sourceLang)
        .single();

      console.log('[translateEpisode] Source transcript:', {
        found: !!sourceTranscript,
        status: sourceTranscript?.status,
        error: sourceTranscriptError?.message
      });

      if (sourceTranscriptError || !sourceTranscript || sourceTranscript.status !== 'completed') {
        toast({
          title: getLocaleString('errorGeneric', currentLanguage),
          description: `–¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç ${sourceLang.toUpperCase()} –Ω–µ –≥–æ—Ç–æ–≤ –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞`,
          variant: 'destructive'
        });
        return false;
      }

      // 2. –°–æ–∑–¥–∞–µ–º —ç–ø–∏–∑–æ–¥ –¥–ª—è —Ü–µ–ª–µ–≤–æ–≥–æ —è–∑—ã–∫–∞ (–µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç)
  let targetSlug;
      if (sourceEpisode.slug.match(/_[a-z]{2}$/)) {
        // –ï—Å–ª–∏ slug —É–∂–µ –∏–º–µ–µ—Ç —è–∑—ã–∫–æ–≤–æ–π —Å—É—Ñ—Ñ–∏–∫—Å, –∑–∞–º–µ–Ω—è–µ–º –µ–≥–æ
        targetSlug = sourceEpisode.slug.replace(/_[a-z]{2}$/, `_${targetLang}`);
      } else {
        // –ï—Å–ª–∏ slug –Ω–µ –∏–º–µ–µ—Ç —è–∑—ã–∫–æ–≤–æ–≥–æ —Å—É—Ñ—Ñ–∏–∫—Å–∞, –¥–æ–±–∞–≤–ª—è–µ–º –µ–≥–æ
        targetSlug = `${sourceEpisode.slug}_${targetLang}`;
      }
      
      console.log('[translateEpisode] Target slug generation:', {
        sourceSlug: sourceEpisode.slug,
        targetLang,
        targetSlug,
        hasLangSuffix: !!sourceEpisode.slug.match(/_[a-z]{2}$/)
      });
      
      const { data: existingTargetEpisode, error: checkError } = await supabase
        .from('episodes')
        .select('id, slug, lang')
        .eq('slug', targetSlug)
        .eq('lang', targetLang)
        .maybeSingle();

      if (checkError && checkError.code !== 'PGRST116') {
        throw checkError;
      }

      if (!existingTargetEpisode) {
        // –ü–µ—Ä–µ–≤–æ–¥–∏–º –Ω–∞–∑–≤–∞–Ω–∏–µ —ç–ø–∏–∑–æ–¥–∞
        console.log('[translateEpisode] Translating episode title:', sourceEpisode.title);
        const translatedTitle = await translateTextOpenAI(
          sourceEpisode.title,
          targetLang,
          currentLanguage
        );
        
        if (!translatedTitle || translatedTitle.trim() === '') {
          console.warn('[translateEpisode] Empty title translation, using original');
        }

        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —ç–ø–∏–∑–æ–¥ –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞
        // –ö–æ–ø–∏—Ä—É–µ–º –∞—É–¥–∏–æ —Å—Å—ã–ª–∫—É –∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ —ç–ø–∏–∑–æ–¥–∞ (–∫–∞–∫ –≤ –¥—Ä—É–≥–∏—Ö —á–∞—Å—Ç—è—Ö –∫–æ–¥–∞)
        // –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç —Å–ª—É—à–∞—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –∞—É–¥–∏–æ –≤ –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–Ω–æ–π –≤–µ—Ä—Å–∏–∏
        const { error: insertError } = await supabase
          .from('episodes')
          .insert([{
            slug: targetSlug,
            title: translatedTitle?.trim() || sourceEpisode.title,
            lang: targetLang,
            date: sourceEpisode.date,
            audio_url: sourceEpisode.audio_url || '',
            r2_object_key: sourceEpisode.r2_object_key || '',
            r2_bucket_name: sourceEpisode.r2_bucket_name || '',
            duration: sourceEpisode.duration || 0,
            file_has_lang_suffix: true,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          }]);

        if (insertError) {
          throw new Error(`–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —ç–ø–∏–∑–æ–¥–∞: ${insertError.message}`);
        }
      } else if (overwrite) {
        // –ï—Å–ª–∏ —ç–ø–∏–∑–æ–¥ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –≤–∫–ª—é—á–µ–Ω overwrite, —Å–æ–æ–±—â–∏–º –≤ –ª–æ–≥
        console.log('[translateEpisode] Target episode exists, will overwrite transcript and questions:', {
          targetSlug,
          targetLang
        });
      }

      // 3. –ü–µ—Ä–µ–≤–æ–¥–∏–º —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ questionsOnly)
      if (!questionsOnly) {
        toast({
          title: 'üîÑ –ü–µ—Ä–µ–≤–æ–¥ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞',
          description: `–ü–µ—Ä–µ–≤–æ–¥–∏–º —Å ${sourceLang.toUpperCase()} –Ω–∞ ${targetLang.toUpperCase()}...`
        });

        const translatedTranscript = await translateTranscriptOpenAI(
          sourceTranscript.edited_transcript_data || sourceTranscript.transcript_data,
          targetLang,
          currentLanguage,
          (current, total, message) => {
            setTranslationProgress({
              [translationKey]: {
                current,
                total,
                message,
                percentage: Math.round((current / total) * 100)
              }
            });
          }
        );

        if (!translatedTranscript || !translatedTranscript.utterances) {
          throw new Error('–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞: –ø–æ–ª—É—á–µ–Ω –ø—É—Å—Ç–æ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç');
        }

        // 4. –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–Ω—ã–π —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç
        // –ï—Å–ª–∏ overwrite –≤–∫–ª—é—á–µ–Ω, —É–¥–∞–ª–∏–º —Å—Ç–∞—Ä—ã–π —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç –ø–µ—Ä–µ–¥ upsert, —á—Ç–æ–±—ã –æ—á–∏—Å—Ç–∏—Ç—å –ª–∏—à–Ω–∏–µ –ø–æ–ª—è
        if (overwrite) {
          try {
            await supabase
              .from('transcripts')
              .delete()
              .eq('episode_slug', targetSlug)
              .eq('lang', targetLang);
          } catch (e) {
            console.warn('[translateEpisode] Failed to delete existing transcript before overwrite (continuing):', e?.message);
          }
        }
        const compactTranslated = buildEditedTranscriptData(translatedTranscript);
        
        const { error: transcriptUpsertError } = await supabase
          .from('transcripts')
          .upsert([{
            episode_slug: targetSlug,
            lang: targetLang,
            status: 'completed',
            edited_transcript_data: compactTranslated,
            updated_at: new Date().toISOString()
          }], {
            onConflict: 'episode_slug,lang'
          });

        if (transcriptUpsertError) {
          throw new Error(`–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞: ${transcriptUpsertError.message}`);
        }
      }

      // 5. –ü–µ—Ä–µ–≤–æ–¥–∏–º –≤–æ–ø—Ä–æ—Å—ã (–µ—Å–ª–∏ –µ—Å—Ç—å)
      const { data: sourceQuestions, error: questionsError } = await supabase
        .from('questions')
        .select('*')
        .eq('episode_slug', sourceEpisode.slug)
        .eq('lang', sourceLang);

      console.log('[translateEpisode] Source questions:', {
        found: !!sourceQuestions,
        count: sourceQuestions?.length || 0,
        error: questionsError?.message
      });

      if (!questionsError && sourceQuestions && sourceQuestions.length > 0) {
        toast({
          title: questionsOnly ? 'üîÑ –ü–µ—Ä–µ–≤–æ–¥ —Ç–æ–ª—å–∫–æ –≤–æ–ø—Ä–æ—Å–æ–≤' : 'üîÑ –ü–µ—Ä–µ–≤–æ–¥ –≤–æ–ø—Ä–æ—Å–æ–≤',
          description: `–ü–µ—Ä–µ–≤–æ–¥–∏–º ${sourceQuestions.length} –≤–æ–ø—Ä–æ—Å–æ–≤ —Å ${sourceLang.toUpperCase()} –Ω–∞ ${targetLang.toUpperCase()}...`
        });

        const translatedQuestions = [];
        let successCount = 0;
        let errorCount = 0;

        for (const question of sourceQuestions) {
          try {
            console.log(`[translateEpisode] Translating question: "${question.title}"`);
            
            const translatedTitle = await translateTextOpenAI(
              question.title,
              targetLang,
              currentLanguage
            );

            if (!translatedTitle || translatedTitle.trim() === '') {
              console.warn(`Empty translation for question: ${question.title}`);
              errorCount++;
              continue;
            }

            console.log(`[translateEpisode] Translated: "${question.title}" -> "${translatedTitle}"`);

            translatedQuestions.push({
              episode_slug: targetSlug,
              lang: targetLang,
              time: question.time,
              title: translatedTitle.trim(),
              created_at: new Date().toISOString()
            });
            
            successCount++;
          } catch (error) {
            console.error(`Error translating question: ${question.title}`, error);
            errorCount++;
            // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å –¥—Ä—É–≥–∏–º–∏ –≤–æ–ø—Ä–æ—Å–∞–º–∏, –Ω–æ –ª–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É
          }
        }

        console.log(`[translateEpisode] Questions translation summary:`, {
          total: sourceQuestions.length,
          success: successCount,
          errors: errorCount
        });

        if (translatedQuestions.length > 0) {
          // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –≤–æ–ø—Ä–æ—Å—ã –¥–ª—è —Ü–µ–ª–µ–≤–æ–≥–æ —è–∑—ã–∫–∞ (–∏–ª–∏ –≤—Å–µ–≥–¥–∞, –µ—Å–ª–∏ overwrite)
          if (overwrite) {
            await supabase
              .from('questions')
              .delete()
              .eq('episode_slug', targetSlug)
              .eq('lang', targetLang);
          }

          // –í—Å—Ç–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã
          const { error: questionsInsertError } = await supabase
            .from('questions')
            .insert(translatedQuestions);

          if (questionsInsertError) {
            console.warn('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤–æ–ø—Ä–æ—Å–æ–≤:', questionsInsertError);
            toast({
              title: '‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤–æ–ø—Ä–æ—Å–æ–≤',
              description: `–ü–µ—Ä–µ–≤–µ–¥–µ–Ω–æ ${translatedQuestions.length} –≤–æ–ø—Ä–æ—Å–æ–≤, –Ω–æ –≤–æ–∑–Ω–∏–∫–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏`,
              variant: 'destructive',
              duration: 5000
            });
          } else {
            console.log(`–£—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–æ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ ${translatedQuestions.length} –≤–æ–ø—Ä–æ—Å–æ–≤`);
            toast({
              title: '‚úÖ –í–æ–ø—Ä–æ—Å—ã –ø–µ—Ä–µ–≤–µ–¥–µ–Ω—ã',
              description: `–£—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–æ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ ${translatedQuestions.length} –≤–æ–ø—Ä–æ—Å–æ–≤`,
              duration: 3000
            });
          }
        } else {
          console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–≤–µ—Å—Ç–∏ –Ω–∏ –æ–¥–Ω–æ–≥–æ –≤–æ–ø—Ä–æ—Å–∞');
          toast({
            title: '‚ö†Ô∏è –í–æ–ø—Ä–æ—Å—ã –Ω–µ –ø–µ—Ä–µ–≤–µ–¥–µ–Ω—ã',
            description: '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–≤–µ—Å—Ç–∏ –Ω–∏ –æ–¥–Ω–æ–≥–æ –≤–æ–ø—Ä–æ—Å–∞',
            variant: 'destructive',
            duration: 5000
          });
        }
      }

      // 6. –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —ç–ø–∏–∑–æ–¥–æ–≤
      if (setEpisodes) {
        // –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —ç–ø–∏–∑–æ–¥–∞ —Å —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–æ–º –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –≤–æ–ø—Ä–æ—Å–æ–≤
        const { data: updatedEpisode } = await supabase
          .from('episodes')
          .select('*')
          .eq('slug', targetSlug)
          .eq('lang', targetLang)
          .single();

        const { data: transcript } = await supabase
          .from('transcripts')
          .select('id, episode_slug, lang, status, assemblyai_transcript_id, updated_at')
          .eq('episode_slug', targetSlug)
          .eq('lang', targetLang)
          .single();

        const { count: questionsCount } = await supabase
          .from('questions')
          .select('*', { count: 'exact', head: true })
          .eq('episode_slug', targetSlug)
          .eq('lang', targetLang);

        if (updatedEpisode) {
          const episodeWithData = {
            ...updatedEpisode,
            transcript: transcript || null,
            questionsCount: questionsCount || 0
          };

          setEpisodes(prev => {
            const filtered = prev.filter(e => !(e.slug === targetSlug && e.lang === targetLang));
            return [...filtered, episodeWithData];
          });

          // –£–≤–µ–¥–æ–º–ª—è–µ–º –æ —Ç–æ–º, —á—Ç–æ –¥–∞–Ω–Ω—ã–µ —ç–ø–∏–∑–æ–¥–∞ –æ–±–Ω–æ–≤–∏–ª–∏—Å—å
          // –≠—Ç–æ –ø–æ–º–æ–∂–µ—Ç –¥—Ä—É–≥–∏–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞–º –æ–±–Ω–æ–≤–∏—Ç—å —Å–≤–æ–∏ –¥–∞–Ω–Ω—ã–µ
          window.dispatchEvent(new CustomEvent('episodeUpdated', {
            detail: { slug: targetSlug, lang: targetLang, episode: episodeWithData }
          }));
        }
      }

      toast({
        title: '‚úÖ –ü–µ—Ä–µ–≤–æ–¥ –∑–∞–≤–µ—Ä—à–µ–Ω',
        description: `–≠–ø–∏–∑–æ–¥ —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–≤–µ–¥–µ–Ω –Ω–∞ ${targetLang.toUpperCase()}`,
        duration: 5000
      });

      return true;

    } catch (error) {
      console.error('Translation error:', error);
      
      let errorMessage = error.message;
      if (error.message?.includes('API key')) {
        errorMessage = '–ü—Ä–æ–±–ª–µ–º–∞ —Å API –∫–ª—é—á–æ–º DeepSeek. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.';
      } else if (error.message?.includes('network') || error.message?.includes('fetch')) {
        errorMessage = '–û—à–∏–±–∫–∞ —Å–µ—Ç–∏. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É.';
      } else if (error.message?.includes('timeout')) {
        errorMessage = '–¢–∞–π–º–∞—É—Ç –∑–∞–ø—Ä–æ—Å–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.';
      } else if (error.message?.includes('rate limit')) {
        errorMessage = '–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤. –ü–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ.';
      }
      
      toast({
        title: getLocaleString('errorGeneric', currentLanguage),
        description: `–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞ –Ω–∞ ${targetLang.toUpperCase()}: ${errorMessage}`,
        variant: 'destructive',
        duration: 8000
      });
      return false;
    } finally {
      console.log('[translateEpisode] Resetting translatingFrom state');
      setIsTranslating(false);
      setTranslatingFrom(null);
      setTranslationProgress({});
    }
  }, [currentLanguage, toast, setEpisodes, isTranslating]);

  // –ú–∞—Å—Å–æ–≤—ã–π –ø–µ—Ä–µ–≤–æ–¥ –≤—Å–µ—Ö —ç–ø–∏–∑–æ–¥–æ–≤ —Å —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —è–∑—ã–∫–∞
  const batchTranslateFromLanguage = useCallback(async (episodes, sourceLang, targetLangs, options = {}) => {
    // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤ –º–∞—Å—Å–æ–≤–æ–º —Ä–µ–∂–∏–º–µ –ù–ï –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ–º ‚Äî –ø–µ—Ä–µ–≤–æ–¥–∏–º —Ç–æ–ª—å–∫–æ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ/–Ω–µ–∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ
    const overwrite = options?.overwrite ?? false;
    const sourceEpisodes = episodes.filter(e => e.lang === sourceLang && e.transcript?.status === 'completed');
    
    if (sourceEpisodes.length === 0) {
      toast({
        title: getLocaleString('errorGeneric', currentLanguage),
        description: `–ù–µ—Ç —ç–ø–∏–∑–æ–¥–æ–≤ ${sourceLang.toUpperCase()} —Å –∑–∞–≤–µ—Ä—à–µ–Ω–Ω–æ–π —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–µ–π`,
        variant: 'destructive'
      });
      return;
    }

    toast({
      title: 'üöÄ –ú–∞—Å—Å–æ–≤—ã–π –ø–µ—Ä–µ–≤–æ–¥',
      description: `–ù–∞—á–∏–Ω–∞–µ–º –ø–µ—Ä–µ–≤–æ–¥ ${sourceEpisodes.length} —ç–ø–∏–∑–æ–¥–æ–≤ –Ω–∞ ${targetLangs.length} —è–∑—ã–∫–æ–≤`,
      duration: 5000
    });

    let successCount = 0;
    let failCount = 0;
    let skippedCount = 0;

    const getTargetSlug = (slug, targetLang) => {
      if (slug.match(/_[a-z]{2}$/)) {
        return slug.replace(/_[a-z]{2}$/, `_${targetLang}`);
      }
      return `${slug}_${targetLang}`;
    };

    for (const episode of sourceEpisodes) {
      for (const targetLang of targetLangs) {
        // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º, –µ—Å–ª–∏ —É–∂–µ –µ—Å—Ç—å –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥ –∏ overwrite –≤—ã–∫–ª—é—á–µ–Ω
        try {
          const targetSlug = getTargetSlug(episode.slug, targetLang);
          const existing = episodes.find(e => e.slug === targetSlug && e.lang === targetLang);
          const isTranslated = existing?.transcript?.status === 'completed';
          if (!overwrite && isTranslated) {
            skippedCount++;
            continue;
          }
        } catch (e) {
          // –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ ‚Äî –Ω–µ —Å–∫–∏–ø–∞–µ–º, –∞ –ø—Ä–æ–±—É–µ–º –ø–µ—Ä–µ–≤–µ—Å—Ç–∏
        }

        const success = await translateEpisode(episode, targetLang, sourceLang, { overwrite });
        if (success) {
          successCount++;
        } else {
          failCount++;
        }
      }
    }

    const summary = `–£—Å–ø–µ—à–Ω–æ: ${successCount}, –ü—Ä–æ–ø—É—â–µ–Ω–æ (—É–∂–µ –ø–µ—Ä–µ–≤–µ–¥–µ–Ω—ã): ${skippedCount}, –û—à–∏–±–æ–∫: ${failCount}`;
    toast({
      title: successCount > 0 ? '‚úÖ –ú–∞—Å—Å–æ–≤—ã–π –ø–µ—Ä–µ–≤–æ–¥ –∑–∞–≤–µ—Ä—à–µ–Ω' : (failCount > 0 ? '‚ùå –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞' : '‚ÑπÔ∏è –ù–µ—á–µ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–∏—Ç—å'),
      description: summary,
      variant: failCount > 0 ? 'destructive' : 'default',
      duration: 8000
    });
  }, [currentLanguage, toast, translateEpisode]);

  return {
    translateEpisode,
    batchTranslateFromLanguage,
    translatingFrom,
    translationProgress
  };
};

export default useTranslationManager;


